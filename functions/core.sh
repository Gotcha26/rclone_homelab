###############################################################################
# Fonction help (aide)
###############################################################################

show_help() {
    cat <<EOF
Usage: $(basename "$0") [OPTIONS]

Options :
  --auto             Lance le script en mode automatique (A DEFINIR).
  --mailto=ADRESSE   Envoie un rapport par e-mail √† l'adresse fournie.
  --dry-run          Simule la synchronisation sans transf√©rer ni supprimer de fichiers.
  -h, --help         Affiche cette aide et quitte.
  --force-update     Mettre √† jour automatiquement sur la branche en cours. Acc√®pte l'argument "branche"
  --update-tag       Mettre √† jour automatiquement sur la release (version) disponnible.

Description :
  Ce script lit la liste des jobs √† ex√©cuter depuis le fichier :
      $DIR_JOBS_FILE
  Chaque ligne doit contenir :
      chemin_source|remote:chemin_destination
  Les lignes vides ou commen√ßant par '#' sont ignor√©es.

  Exemple de ligne :
      /home/user/Documents|OneDrive:Backups/Documents

Fonctionnement :
  - V√©rifie et teste les pr√©-requis au bon d√©roulement des op√©rations.
  - Lance 'rclone sync' pour chaque job avec les options par d√©faut
  - Affiche la sortie coloris√©e dans le terminal
  - G√©n√®re un fichier log INFO dans : $DIR_LOG
  - Si --mailto est fourni et msmtp est configur√©, envoie un rapport HTML
EOF
}


###############################################################################
# Fonction : Surcharger global.conf < config.local.conf < config.dev.conf < secrets.env (si pr√©sents)
# Utilise display_msg() pour tout affichage
# DISPLAY_MODE possible : soft (aucun affichage) | verbose (messages d√©taill√©s)
###############################################################################
load_optional_configs() {
    local any_loaded=false

    local configs=(
        "$DIR_CONF_LOCAL_FILE|CONFIGURATION LOCALE ACTIV√âE ‚ÑπÔ∏è"
        "$DIR_CONF_DEV_FILE|CONFIGURATION DEV ACTIV√âE ‚ÑπÔ∏è"
        "$DIR_SECRET_FILE|SECRETS LOADED ‚ÑπÔ∏è"
    )

    for entry in "${configs[@]}"; do
        IFS="|" read -r file msg <<< "$entry"
        if [[ -f "$file" && -r "$file" ]]; then
            source "$file"
            any_loaded=true

            # On peut d√©cider quel type de message on veut ici
            display_msg "verbose|hard" --theme success "$(basename "$file") charg√©"
        fi
    done

    if [[ "$any_loaded" == false ]]; then
        display_msg "verbose" --theme info "Configuration par d√©faut uniquement."
        display_msg "hard" --theme info "Aucun fichier de configuration optionnel trouv√©. Configuration par d√©faut uniquement."
    fi
}


###############################################################################
# Fonction : Cycle de v√©rifications pour rclone
###############################################################################
check_rclone() {
    local status=0
    local conf_file=""

    # V√©rif binaire rclone
    if ! check_rclone_installed; then
        if [[ "$ACTION_MODE" == "manu" ]]; then
            display_msg "soft|verbose|hard" "‚ùó  rclone n'est pas install√©, proposition d'installation."
            install_rclone || return 11
        else
            status=11
        fi
    else
        display_msg "verbose|hard" --theme ok "rclone est install√©."
        # V√©rif configuration et capture chemin du fichier valide
        if conf_file="$(check_rclone_configured 2>/dev/null)"; then
            status=0
        else
            case $? in
                1) status=31 ;;   # Config vide/inutilisable
                2) status=32 ;;   # Aucun fichier trouv√©
            esac
        fi
    fi

    # Tableau : code -> "th√®me¬§message"
    declare -A MSGS=(
        [11]="warning¬§rclone n'est pas install√©. Le script va s'arr√™ter."
        [31]="error¬§Fichier rclone d√©tect√© mais inutilisable."
        [32]="warning¬§Aucun fichier rclone.conf trouv√©."
    )

    case $status in
        0)
            # Affichage succ√®s avec chemin et pr√©cision de provenance
            local source_type="inconnu"
            if [[ -n "${RCLONE_CONFIG:-}" && "$RCLONE_CONFIG" == "$conf_file" ]]; then
                source_type="variable d'environnement"
            elif [[ "$conf_file" == "$HOME/.config/rclone/rclone.conf" ]]; then
                source_type="dossier utilisateur"
            elif [[ "$conf_file" == "/etc/rclone.conf" ]]; then
                source_type="configuration globale"
            fi

            display_msg "verbose|hard" --theme ok "Fichier rclone valide trouv√© ($source_type) : "
            display_msg "verbose|hard" --align right --fg blue "$conf_file"
            return 0
            ;;
        11|31|32)
            IFS="¬§" read -r --theme message <<< "${MSGS[$status]}"
            if [[ "$ACTION_MODE" == "auto" ]]; then
                die "$status" "$message"
            else
                display_msg "soft|verbose|hard" --theme "$theme" "$message"
                display_msg "soft|verbose|hard" ""  # ligne vide
                display_msg "soft|verbose|hard" --theme follow \
                    "Utilisez le menu interactif pour √©diter/reconfigurer rclone."
                return "$status"
            fi
            ;;
    esac
}


###############################################################################
# Fonction : V√©rifier si rclone est install√©
###############################################################################
check_rclone_installed() {
    command -v rclone >/dev/null 2>&1
}


###############################################################################
# V√©rifie si rclone est configur√©
# Retour :
#   0 -> fichier valide trouv√© (chemin √©mis sur stdout)
#   1 -> fichier trouv√© mais vide/inutilisable
#   2 -> aucun fichier trouv√©
# Usage :
#   conf_file="$(check_rclone_configured 2>/dev/null)" ; rc=$?
#   if (( rc == 0 )); then ... use "$conf_file" ... fi
###############################################################################
check_rclone_configured() {
    local candidates=()
    local conf_file
    local found=0

    # 1. Variable d'environnement RCLONE_CONFIG si d√©finie
    [[ -n "${RCLONE_CONFIG:-}" ]] && candidates+=("$RCLONE_CONFIG")

    # 2. Fichier utilisateur standard (~/.config/rclone/rclone.conf)
    [[ -n "$HOME" ]] && candidates+=("$HOME/.config/rclone/rclone.conf")

    # 3. Fichier global syst√®me
    candidates+=("/etc/rclone.conf")

    for conf_file in "${candidates[@]}"; do
        if [[ -f "$conf_file" && -r "$conf_file" ]]; then
            local filesize
            filesize=$(stat -c %s "$conf_file" 2>/dev/null || echo 0)
            if (( filesize > 0 )); then
                # succ√®s : on √©met le chemin sur stdout (pour capture) et return 0
                printf '%s\n' "$conf_file"
                return 0
            else
                # trouv√© mais vide
                found=1
            fi
        fi
    done

    if (( found == 1 )); then
        return 1
    fi

    return 2
}


###############################################################################
# Fonction : Installer rclone si absent
###############################################################################
install_rclone() {
    # Cas ACTION_MODE=manu ‚Üí on demande confirmation
    echo
    read -e -rp "üì¶  Voulez-vous installer rclone maintenant ? [y/N] : " REPLY
    REPLY=${REPLY,,}
    if [[ "$REPLY" != "y" && "$REPLY" != "yes" ]]; then
        die 11 "Installation de rclone refus√©e par l'utilisateur."
    fi

    # Tentative d‚Äôinstallation
    display_msg "verbose|hard" --theme follow "Installation de rclone en cours..."
    if sudo apt update && sudo apt install -y rclone; then
        display_msg "soft|verbose|hard" --theme ok "rclone a √©t√© install√© avec succ√®s."
        return 0
    else
        die 11 "Une erreur est survenue lors de l'installation de rclone."
    fi
}


###############################################################################
# Fonction : V√©rifier l'existence, la lisibilit√© et le contenu du fichier jobs
# Retour : 0 si OK, 1 si KO
###############################################################################
check_jobs_file() {
    # V√©rifier pr√©sence
    [[ -f "$DIR_JOBS_FILE" ]] || { [[ "$ACTION_MODE" == "auto" ]] && \
        die 3 "Fichier jobs introuvable : $DIR_JOBS_FILE"; return 1; }

    # V√©rifier lisibilit√©
    [[ -r "$DIR_JOBS_FILE" ]] || { [[ "$ACTION_MODE" == "auto" ]] && \
        die 4 "Fichier jobs non lisible : $DIR_JOBS_FILE"; return 1; }

    # V√©rifier contenu (au moins une ligne non vide et non comment√©e)
    grep -qEv '^[[:space:]]*($|#)' "$DIR_JOBS_FILE" || { [[ "$ACTION_MODE" == "auto" ]] && \
        die 5 "Aucun job valide trouv√© dans $DIR_JOBS_FILE"; return 1; }

    # Tout est bon si on arrive jusqu'i√ßi
    [[ "$ACTION_MODE" == "auto" ]] && display_msg "verbose|hard" --theme ok "Consultation des jobs : pass√©e"

    return 0
}


###############################################################################
# Fonction : Edit ele bon fichier de configuration de msmtp (si installation atypique)
###############################################################################
edit_msmtp_config() {
    local conf_file
    conf_file="$(check_msmtp_configured)" || {
        conf_file="${MSMTPRC:-$HOME/.msmtprc}"
        print_fancy --theme "warning" "Aucun fichier msmtp valide trouv√©, cr√©ation de : $conf_file"
        touch "$conf_file" && chmod 600 "$conf_file"
    }

    print_fancy --theme "info" "√âdition du fichier msmtp : $conf_file"
    $EDITOR "$conf_file"
}



###############################################################################
# Fonction d'affichage du tableau r√©capitulatif avec bordures
###############################################################################
print_aligned_table() {
    local label="$1"
    local value="$2"
    local label_width=20

    # Calcul de la longueur du label
    local label_len=${#label}
    local spaces=$((label_width - label_len))

    # G√©n√®re les espaces √† ajouter apr√®s le label
    local padding=""
    if (( spaces > 0 )); then
        padding=$(printf '%*s' "$spaces" '')
    fi

    # Affiche la ligne avec label + padding + " : " + value
    printf "%s%s : %s\n" "$label" "$padding" "$value"
}


###############################################################################
# Fonction : Affiche le r√©sum√© de la t√¢che rclone
###############################################################################
print_summary_table() {
    END_TIME="$(date '+%Y-%m-%d %H:%M:%S')"

    echo
    echo "INFOS"
    printf '%*s\n' "$TERM_WIDTH_DEFAULT" '' | tr ' ' '='

    print_aligned_table "Date / Heure d√©but"  "$(safe_var "START_TIME")"
    print_aligned_table "Date / Heure fin"    "$END_TIME"
    print_aligned_table "Mode de lancement"   "$(safe_var "LAUNCH_MODE")"
    print_aligned_table "Nb. de jobs trait√©s" "$(safe_var "EXECUTED_JOBS") / $(safe_count JOBS_LIST)"
    print_aligned_table "Dernier code erreur" "$(safe_var "ERROR_CODE")"
    print_aligned_table "Dossier"             "$(safe_var "DIR_LOG")/"
    print_aligned_table "Log mail"            "$(safe_var "LOG_FILE_MAIL")"
    print_aligned_table "Log rclone"          "$(safe_var "LOG_FILE_INFO")"

    if [[ -n "${MAIL_TO:-}" ]]; then
        print_aligned_table "Email envoy√© √†" "$(safe_var "MAIL_TO")"
        print_aligned_table "Sujet email"    "$(safe_var "SUBJECT_RAW")"
    fi

    if [[ -n "${DISCORD_WEBHOOK_URL:-}" ]]; then
        print_aligned_table "Notifs Discord" "$(safe_var "Trait√©e(s)")"
    else
        print_aligned_table "Notifs Discord" "$(safe_var "‚ö†Ô∏è  Aucun webhook Discord de d√©fini.")"
    fi

    print_aligned_table "Simulation (dry-run)" "$(safe_var "‚úÖ  Oui : aucune modification de fichiers.")"

    printf '%*s\n' "$TERM_WIDTH_DEFAULT" '' | tr ' ' '='
    print_fancy --align "center" --bg "yellow" --fg "black" "$(safe_var "--- Fin de rapport ---")"
    echo
}


###############################################################################
# Fonction : Retourne la valeur d'une variable
#   - Si variable non d√©clar√©e : "-nc-"
#   - Si variable d√©clar√©e mais vide : "-ABSENT-"
#   - Sinon : la valeur
# Usage :
#   safe_var VAR_NAME
###############################################################################
safe_var() {
    local varname="$1"

    if ! declare -p "$varname" &>/dev/null; then
        echo "-nc-"
    else
        local val="${!varname}"
        [[ -z "$val" ]] && echo "-ABSENT-" || echo "$val"
    fi
}


###############################################################################
# Fonction : Pour les tableaux : renvoie la taille, ou 0 si non d√©fini
###############################################################################
safe_count() {
    local -n arr="${1:-}" 2>/dev/null || { echo 0; return; }
    echo "${#arr[@]}"
}


###############################################################################
# Fonction : Cr√©ation des r√©pertoires temporaires n√©cessaires
###############################################################################
create_temp_dirs() {
    # DIR_TMP
    if [[ ! -d "$DIR_TMP" ]]; then
        mkdir -p "$DIR_TMP" 2>/dev/null || die 1 "Impossible de cr√©er le dossier temporaire : $DIR_TMP"
    fi

    # DIR_LOG
    if [[ ! -d "$DIR_LOG" ]]; then
        mkdir -p "$DIR_LOG" 2>/dev/null || die 2 "Impossible de cr√©er le dossier de logs : $DIR_LOG"
    fi
}


###############################################################################
# Fonction : Ajouter des options √† rclone [OBSOLETE]
###############################################################################
add_rclone_opts() {
    if [[ "${DRY_RUN:-false}" == true ]]; then
        RCLONE_OPTS+=(--dry-run)
    fi
}


###############################################################################
# Fonction : Int√©rroger le num√©ro de version/tag/release (local ou git)
###############################################################################
get_current_version() {
    if [[ -s "$DIR_VERSION_FILE" ]]; then
        head -n1 "$DIR_VERSION_FILE" | tr -d '\r\n'
    else
        echo "-NC-"
    fi
}


###############################################################################
# Fonction : Edition de la configuration locale (si pr√©sente...)
###############################################################################
mini_edit_local_config() {
    local candidates=(
        "$DIR_CONF_LOCAL_FILE"
        "$DIR_CONF_DEV_FILE"
        "$DIR_SECRET_FILE"
    )

    # Filtrer uniquement les fichiers existants
    local existing=()
    for f in "${candidates[@]}"; do
        [[ -f "$f" ]] && existing+=("$f")
    done

    if [[ ${#existing[@]} -eq 0 ]]; then
        return 1
    fi

    echo
    echo "Fichiers disponibles pour √©dition :"
    echo
    local i=1
    for f in "${existing[@]}"; do
        echo "[$i] $f"
        ((i++))
    done
    echo "[$i] Retour"
    echo

    read -e -rp "Choisir un fichier √† √©diter [1-$i] : " subchoice

    if [[ "$subchoice" -ge 1 && "$subchoice" -lt "$i" ]]; then
        local target="${existing[$((subchoice-1))]}"
        ${EDITOR:-nano} "$target"
    fi
}


###############################################################################
# Fonction : D√©sinstallation g√©n√©rique d'un binaire/paquet avec menu et √©tat
# Usage    : dev_uninstall [binaire]
###############################################################################
dev_uninstall() {
    local binary_name="${1:-}"
    local debian_pkgs=""

    # Liste support√©e
    local supported=("rclone" "msmtp" "colordiff" "git" "curl" "unzip" "perl" "jq")

    # Si pas d‚Äôargument ‚Üí afficher menu
    if [[ -z "${binary_name:-}" ]]; then
        echo
        echo "üì¶  S√©lectionne le logiciel √† d√©sinstaller :"
        echo
        local i=1
        for item in "${supported[@]}"; do
            if command -v "$item" >/dev/null 2>&1; then
                local status="install√©"
            else
                local status="absent"
            fi
            printf "  %d) %s [%s]\n" "$i" "$item" "$status"
            ((i++))
        done
        printf "  q) Quitter\n"

        read -rp "üëâ  Ton choix : " choice
        if [[ "$choice" == "q" ]]; then
            echo "‚ùå  Abandon."
            return 0
        elif [[ "$choice" =~ ^[0-9]+$ ]] && (( choice>=1 && choice<=${#supported[@]} )); then
            binary_name="${supported[$((choice-1))]}"
        else
            echo "‚ùå  Choix invalide."
            return 1
        fi
    fi

    # Table de correspondance binaire ‚Üí paquet(s) Debian
    case "$binary_name" in
        rclone)    debian_pkgs="rclone" ;;
        msmtp)     debian_pkgs="msmtp msmtp-mta" ;;
        colordiff) debian_pkgs="colordiff" ;;
        git)       debian_pkgs="git" ;;
        curl)      debian_pkgs="curl" ;;
        unzip)     debian_pkgs="unzip" ;;
        perl)      debian_pkgs="perl" ;;
        jq)        debian_pkgs="jq" ;;
        *)
            print_fancy --theme error "'$binary_name' n'est pas g√©r√© par ce script."
            return 1
            ;;
    esac

    if ! command -v "$binary_name" >/dev/null 2>&1; then
        print_fancy --theme error "$binary_name n'est pas install√© ou pas dans le PATH."
        return 0
    fi

    local paths
    mapfile -t paths < <(type -aP "$binary_name" | sort -u)

    for path in "${paths[@]}"; do
        print_fancy "üîç $binary_name d√©tect√© √† : $path"

        if dpkg -S "$path" >/dev/null 2>&1; then
            print_fancy --theme ok "Installation via paquet Debian d√©tect√©e."
            print_fancy --theme info "Ex√©cution de : apt remove --purge -y $debian_pkgs && apt autoremove -y"
            sudo apt remove --purge -y $debian_pkgs
            sudo apt autoremove -y
            print_fancy --theme success "$binary_name a √©t√© d√©sinstall√© avec apt."
            return 0
        else
            print_fancy --theme ok "Installation manuelle d√©tect√©e (binaire copi√© directement)."
            print_fancy --theme info "Suppression du fichier : $path"
            sudo rm -f "$path"
            print_fancy --theme success "$binary_name (binaire manuel) supprim√©."
        fi
    done

    # Cas particulier : msmtpq √† supprimer si pr√©sent et manuel
    if [[ "$binary_name" == "msmtp" ]] && command -v msmtpq >/dev/null 2>&1; then
        local msmtpq_path
        msmtpq_path="$(command -v msmtpq)"
        print_fancy "üîç msmtpq d√©tect√© √† : $msmtpq_path"
        if ! dpkg -S "$msmtpq_path" >/dev/null 2>&1; then
            print_fancy --theme info "Suppression du fichier : $msmtpq_path"
            sudo rm -f "$msmtpq_path"
            print_fancy --theme success "msmtpq (binaire manuel) supprim√©."
        fi
    fi
}


###############################################################################
# Fonction : Installation g√©n√©rique d'un binaire/paquet avec menu
# Usage    : dev_install [binaire]
###############################################################################
dev_install() {
    local binary_name="${1:-}"
    local debian_pkgs=""

    # Liste support√©e
    local supported=("colordiff" "git" "curl" "unzip" "perl" "jq")

    # Si pas d‚Äôargument ‚Üí afficher menu
    if [[ -z "${binary_name:-}" ]]; then
        echo
        echo "üì¶  S√©lectionne le logiciel √† installer :"
        echo
        local i=1
        for item in "${supported[@]}"; do
            if command -v "$item" >/dev/null 2>&1; then
                local status="install√©"
            else
                local status="absent"
            fi
            printf "  %d) %s [%s]\n" "$i" "$item" "$status"
            ((i++))
        done
        printf "  q) Quitter\n"

        read -rp "üëâ  Ton choix : " choice
        if [[ "$choice" == "q" ]]; then
            echo "‚ùå  Abandon."
            return 0
        elif [[ "$choice" =~ ^[0-9]+$ ]] && (( choice>=1 && choice<=${#supported[@]} )); then
            binary_name="${supported[$((choice-1))]}"
        else
            echo "‚ùå  Choix invalide."
            return 1
        fi
    fi

    # Table de correspondance binaire ‚Üí paquet(s) Debian
    case "$binary_name" in
        colordiff) debian_pkgs="colordiff" ;;
        git)       debian_pkgs="git" ;;
        curl)      debian_pkgs="curl" ;;
        unzip)     debian_pkgs="unzip" ;;
        perl)      debian_pkgs="perl" ;;
        jq)        debian_pkgs="jq" ;;
        *)
            print_fancy --theme error "'$binary_name' n'est pas g√©r√© par ce script."
            return 1
            ;;
    esac

    if command -v "$binary_name" >/dev/null 2>&1; then
        print_fancy --theme ok "$binary_name est d√©j√† install√©."
        return 0
    fi

    print_fancy "üîç Installation de $binary_name via apt..."
    print_fancy --theme info "Ex√©cution : sudo apt update && sudo apt install -y $debian_pkgs"
    sudo apt update
    sudo apt install -y $debian_pkgs
    print_fancy --theme success "$binary_name install√© avec succ√®s !"
}